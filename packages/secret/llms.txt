# @rytass/secret

Core secret management interfaces and base classes for secure credential handling.

## Package Overview

This package provides the foundational interfaces and abstract classes for secret management systems. It defines standardized patterns for storing, retrieving, and managing sensitive configuration data across different secret management providers.

## Core Features

### Abstract Base Class
- **SecretManager**: Base abstract class for all secret management implementations
- **Project-based Organization**: Secrets organized by project namespace
- **Generic Type Support**: Type-safe secret retrieval and storage
- **Consistent API**: Unified interface across different secret backends

### Core Operations
- **get\<T>(key: string)**: Retrieve typed secrets safely
- **set\<T>(key: string, value: T)**: Store secrets with type information
- **delete(key: string)**: Remove secrets securely
- **Project Management**: Automatic project-based secret organization

## Architecture Design

### Abstract Implementation Pattern
```typescript
abstract class SecretManager {
  private readonly _project: string;
  
  constructor(project: string) {
    this._project = project;
  }

  get project(): string {
    return this._project;
  }

  abstract get<T>(key: string): Promise<T> | T;
  abstract set<T>(key: string, value: T): Promise<void> | void;
  abstract delete(key: string): Promise<void> | void;
}
```

### Implementation Guidelines
Secret manager implementations should:
- **Extend SecretManager**: Inherit from the base abstract class
- **Implement Core Methods**: Provide get, set, and delete operations
- **Handle Async/Sync**: Support both synchronous and asynchronous operations
- **Type Safety**: Maintain generic type information for stored secrets

## Usage Patterns

### Basic Implementation Structure
```typescript
import { SecretManager } from '@rytass/secret';

class MySecretManager extends SecretManager {
  constructor(project: string, config: MyConfig) {
    super(project);
    // Initialize specific backend
  }

  async get<T>(key: string): Promise<T> {
    // Implementation specific logic
  }

  async set<T>(key: string, value: T): Promise<void> {
    // Implementation specific logic
  }

  async delete(key: string): Promise<void> {
    // Implementation specific logic
  }
}
```

### Type-Safe Secret Access
```typescript
interface DatabaseConfig {
  host: string;
  port: number;
  username: string;
  password: string;
}

const secretManager = new MySecretManager('myproject');

// Type-safe retrieval
const dbConfig = await secretManager.get<DatabaseConfig>('database');

// Type-safe storage
await secretManager.set<DatabaseConfig>('database', {
  host: 'localhost',
  port: 5432,
  username: 'user',
  password: 'secret'
});
```

## Security Principles

### Best Practices
- **Project Isolation**: Secrets are isolated by project namespace
- **Type Safety**: Generic types prevent secret misuse
- **Consistent Interface**: Standardized API reduces implementation errors
- **Backend Agnostic**: Abstract design supports multiple secret backends

### Implementation Requirements
Secret managers should implement:
- **Encryption at Rest**: Secure storage of sensitive data
- **Access Control**: Proper authentication and authorization
- **Audit Logging**: Track secret access and modifications
- **Backup and Recovery**: Reliable secret backup mechanisms

## Integration Architecture

### Provider Pattern
This package enables:
- **Multiple Backends**: HashiCorp Vault, AWS Secrets Manager, Azure Key Vault
- **Environment Switching**: Different backends per environment
- **Configuration Management**: Centralized secret configuration
- **Development Workflow**: Local development secret handling

### Extensibility Design
The abstract base class allows for:
- **Custom Implementations**: Provider-specific optimizations
- **Hybrid Approaches**: Multi-backend secret strategies  
- **Testing Support**: Mock implementations for testing
- **Migration Tools**: Cross-provider secret migration

## Security Context

### Enterprise Requirements
Designed to support:
- **Compliance**: SOC2, ISO27001, GDPR requirements
- **Key Rotation**: Automated secret rotation capabilities
- **Access Auditing**: Comprehensive access logging
- **Separation of Duties**: Role-based secret access

### Development Security
Provides foundation for:
- **Local Development**: Secure local secret storage
- **CI/CD Integration**: Automated secret injection
- **Environment Parity**: Consistent secret access patterns
- **Secret Sprawl Prevention**: Centralized secret management

## Dependencies

- **No External Dependencies**: Pure TypeScript interfaces
- **Type-First Design**: Full TypeScript support
- **Runtime Agnostic**: Works in Node.js and browser environments

## Related Packages

- **@rytass/secret-adapter-vault**: HashiCorp Vault implementation
- **@rytass/secret-adapter-vault-nestjs**: NestJS module for Vault integration

This package serves as the foundation for all secret management implementations in the Rytass ecosystem, ensuring consistent, type-safe, and secure secret handling across different applications and environments.