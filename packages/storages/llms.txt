# @rytass/storages

A unified file storage interface for the Rytass ecosystem providing consistent API for managing files across different storage backends including local disk, cloud storage providers, and content delivery networks.

## Package Information

- **Name**: @rytass/storages
- **Version**: 0.2.1
- **Description**: Rytass Utils Storages
- **Author**: MarshallChiang <ambrosia8286@gmail.com>
- **License**: MIT
- **Repository**: https://github.com/Rytass/Utils

## Installation

```bash
npm install @rytass/storages
# or
yarn add @rytass/storages
```

## Core Features

- **Unified Interface**: Consistent API across all storage providers
- **Buffer and Stream Support**: Handle files as buffers or streams
- **Automatic Content Type Detection**: Intelligent MIME type detection
- **File Existence Checking**: Verify file presence before operations
- **Batch Operations**: Upload/download multiple files efficiently
- **TypeScript Support**: Full TypeScript definitions and type safety
- **Extensible Architecture**: Plugin-based adapter system

## Available Adapters

The core storages package works with these official adapters:

- **@rytass/storages-adapter-local**: Local disk storage
- **@rytass/storages-adapter-s3**: Amazon S3 storage
- **@rytass/storages-adapter-r2**: Cloudflare R2 storage  
- **@rytass/storages-adapter-gcs**: Google Cloud Storage
- **@rytass/storages-adapter-azure-blob**: Azure Blob Storage

## Core Storage Interface

All storage adapters implement the base `Storage` abstract class:

```typescript
abstract class Storage<Options extends StorageOptions> {
  abstract url(key: string, expires?: number): Promise<string>;
  abstract read(key: string): Promise<Readable>;
  abstract read(key: string, options: ReadBufferFileOptions): Promise<Buffer>;
  abstract read(key: string, options: ReadStreamFileOptions): Promise<Readable>;
  abstract write(file: InputFile, options?: WriteFileOptions): Promise<StorageFile>;
  abstract batchWrite(files: InputFile[]): Promise<StorageFile[]>;
  abstract remove(key: string): Promise<void>;
  abstract isExists(filename: string): Promise<boolean>;
}
```

## Type Definitions

### File Input Types

```typescript
type InputFile = Buffer | Readable;

interface StorageFile {
  key: string;
}
```

### Operation Options

```typescript
interface WriteFileOptions {
  filename?: string;
  contentType?: string;
}

interface ReadBufferFileOptions {
  format: 'buffer';
}

interface ReadStreamFileOptions {
  format: 'stream';
}
```

## Basic Usage Examples

### S3 Storage Example

```typescript
import { StorageS3Service } from '@rytass/storages-adapter-s3';

const storage = new StorageS3Service({
  region: 'us-west-2',
  bucket: 'my-bucket',
  credentials: {
    accessKeyId: 'your-access-key',
    secretAccessKey: 'your-secret-key'
  }
});

// Upload file
const result = await storage.write(buffer, {
  filename: 'documents/file.pdf',
  contentType: 'application/pdf'
});

// Download file
const fileBuffer = await storage.read('documents/file.pdf', { format: 'buffer' });

// Generate signed URL
const url = await storage.url('documents/file.pdf');
```

### Local Storage Example

```typescript
import { StorageLocalService } from '@rytass/storages-adapter-local';

const storage = new StorageLocalService({
  baseDir: './uploads'
});

// Upload file
const result = await storage.write(buffer, {
  filename: 'images/photo.jpg'
});

// Read file
const fileStream = await storage.read('images/photo.jpg');
```

## Advanced Usage Patterns

### Multi-Provider Storage Manager

```typescript
class MultiStorageManager {
  private primaryStorage: Storage<any>;
  private backupStorage: Storage<any>;

  constructor() {
    this.primaryStorage = new StorageS3Service({
      region: 'us-west-2',
      bucket: 'primary-bucket',
      credentials: {
        accessKeyId: process.env.AWS_ACCESS_KEY_ID!,
        secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY!
      }
    });

    this.backupStorage = new StorageLocalService({
      baseDir: './backup-storage'
    });
  }

  async uploadWithBackup(file: Buffer, filename: string) {
    // Upload to primary storage
    const primaryResult = await this.primaryStorage.write(file, { filename });
    
    // Backup to local storage
    const backupResult = await this.backupStorage.write(file, { filename });
    
    return { primary: primaryResult, backup: backupResult };
  }
}
```

### Storage Proxy with Caching

```typescript
class CachedStorageProxy extends Storage<any> {
  private cache = new Map<string, Buffer>();
  private baseStorage: Storage<any>;

  constructor(baseStorage: Storage<any>) {
    super({} as any);
    this.baseStorage = baseStorage;
  }

  async read(key: string, options?: any): Promise<any> {
    // Check cache for buffer reads
    if (options?.format === 'buffer' && this.cache.has(key)) {
      return this.cache.get(key)!;
    }

    const result = await this.baseStorage.read(key, options);

    // Cache buffer results
    if (options?.format === 'buffer' && Buffer.isBuffer(result)) {
      this.cache.set(key, result);
    }

    return result;
  }

  // ... other methods
}
```

## Framework Integration

### Express.js File Upload

```typescript
import express from 'express';
import multer from 'multer';
import { StorageS3Service } from '@rytass/storages-adapter-s3';

const app = express();
const upload = multer({ storage: multer.memoryStorage() });
const storage = new StorageS3Service(/* config */);

app.post('/upload', upload.single('file'), async (req, res) => {
  try {
    const result = await storage.write(req.file.buffer, {
      filename: `uploads/${Date.now()}-${req.file.originalname}`,
      contentType: req.file.mimetype
    });

    const publicUrl = await storage.url(result.key);
    res.json({ success: true, key: result.key, url: publicUrl });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});
```

### NestJS Service

```typescript
@Injectable()
export class FileStorageService {
  private storage: StorageS3Service | StorageLocalService;

  constructor(private configService: ConfigService) {
    const storageType = this.configService.get('STORAGE_TYPE');

    if (storageType === 's3') {
      this.storage = new StorageS3Service({
        region: this.configService.get('AWS_REGION')!,
        bucket: this.configService.get('S3_BUCKET')!,
        credentials: {
          accessKeyId: this.configService.get('AWS_ACCESS_KEY_ID')!,
          secretAccessKey: this.configService.get('AWS_SECRET_ACCESS_KEY')!
        }
      });
    } else {
      this.storage = new StorageLocalService({
        baseDir: this.configService.get('LOCAL_STORAGE_DIR', './uploads')
      });
    }
  }

  async uploadFile(file: Buffer, filename: string, contentType?: string) {
    return this.storage.write(file, { filename, contentType });
  }
}
```

## File Processing Pipeline

Integration with @rytass/file-converter for processing files before storage:

```typescript
import { ConverterManager } from '@rytass/file-converter';
import { ImageResizer } from '@rytass/file-converter-adapter-image-resizer';

class FileProcessor {
  constructor(
    private storage: Storage<any>,
    private converter: ConverterManager
  ) {}

  async processAndStore(originalFile: Buffer, key: string) {
    // Process the file
    const processedFile = await this.converter.convert<Buffer>(originalFile);

    // Store both original and processed versions
    const [originalResult, processedResult] = await Promise.all([
      this.storage.write(originalFile, { 
        filename: `originals/${key}`,
        contentType: 'image/jpeg'
      }),
      this.storage.write(processedFile, { 
        filename: `processed/${key}`,
        contentType: 'image/webp'
      })
    ]);

    return {
      original: { key: originalResult.key, url: await this.storage.url(originalResult.key) },
      processed: { key: processedResult.key, url: await this.storage.url(processedResult.key) }
    };
  }
}
```

## Error Handling

```typescript
import { StorageError, ErrorCode } from '@rytass/storages';

async function safeFileOperation(storage: Storage<any>, key: string) {
  try {
    const exists = await storage.isExists(key);
    if (!exists) {
      throw new StorageError(ErrorCode.READ_FILE_ERROR, 'File not found');
    }

    return await storage.read(key, { format: 'buffer' });
  } catch (error) {
    if (error instanceof StorageError) {
      console.error('Storage error:', error.code, error.message);
    } else {
      console.error('Unexpected error:', error);
    }
    throw error;
  }
}
```

## Error Types

```typescript
enum ErrorCode {
  READ_FILE_ERROR = 'READ_FILE_ERROR',
  WRITE_FILE_ERROR = 'WRITE_FILE_ERROR',
  FILE_NOT_FOUND = 'FILE_NOT_FOUND'
}

class StorageError extends Error {
  constructor(public code: ErrorCode, message: string);
}
```

## Best Practices

### Security
- Use environment variables for credentials
- Implement proper access controls
- Validate file types before upload
- Sanitize file names
- Use signed URLs for temporary access

### Performance
- Use streams for large files
- Implement caching for frequently accessed files
- Use batch operations when possible
- Choose appropriate storage classes/tiers

### Cost Optimization
- Monitor storage usage
- Set up lifecycle policies
- Use appropriate redundancy levels
- Optimize file sizes before storage

### File Organization
- Use consistent naming conventions
- Organize files in logical directory structures
- Implement proper versioning
- Consider data retention policies

## Dependencies

- **@rytass/file-converter**: ^0.1.2 - File processing and conversion utilities
- **file-type**: ^16 - File type detection from buffer content

## Related Packages

- **@rytass/file-converter**: File processing and transformation
- **@rytass/file-converter-adapter-image-resizer**: Image resizing capabilities
- **@rytass/file-converter-adapter-image-transcoder**: Image format conversion
- **@rytass/file-converter-adapter-image-watermark**: Image watermarking

## Testing

All storage adapters should be thoroughly tested with:
- File upload and download operations
- Stream processing for large files
- Error handling scenarios
- Batch operations
- File existence checking
- URL generation

## Support

- **Issues**: https://github.com/Rytass/Utils/issues
- **Documentation**: https://github.com/Rytass/Utils#readme
- **License**: MIT

## Changelog

### Version 0.2.1
- Updated dependencies
- Enhanced TypeScript support
- Improved error handling
- Added batch operation support