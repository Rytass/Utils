# @rytass/wms-base-nestjs-module

Warehouse Management System (WMS) base module for NestJS applications.

## Package Overview

This package provides a foundational warehouse management system for NestJS applications, designed to handle inventory tracking, stock management, order fulfillment, and warehouse operations. It offers a flexible architecture for building comprehensive warehouse management solutions with TypeORM integration.

## Core Features

### Inventory Management
- **Stock Tracking**: Real-time inventory levels with location tracking
- **Batch Management**: Lot and batch tracking for traceability
- **Location Management**: Warehouse zone and bin location organization
- **Material Master**: Comprehensive product and material information management

### Order Management
- **Order Processing**: Inbound and outbound order handling
- **Fulfillment Workflow**: Pick, pack, and ship order processing
- **Order Status Tracking**: Complete order lifecycle management
- **Priority Handling**: Order prioritization and scheduling

### Warehouse Operations
- **Location Hierarchy**: Zone, aisle, rack, and bin organization
- **Stock Movements**: Track all inventory movements and transfers
- **Inventory Adjustments**: Handle stock discrepancies and corrections
- **Reporting**: Comprehensive warehouse performance reporting

## Database Schema

### Core Entities
- **Material**: Product/item master data
- **Location**: Warehouse location hierarchy
- **Stock**: Current inventory levels by location and batch
- **Batch**: Lot tracking and batch information
- **Order**: Inbound and outbound orders

### Entity Relationships
- Material ↔ Stock (one-to-many)
- Location ↔ Stock (one-to-many)
- Batch ↔ Stock (one-to-many)
- Order ↔ OrderItems (one-to-many)

## Usage Examples

### Module Configuration
```typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { WmsBaseModule } from '@rytass/wms-base-nestjs-module';

@Module({
  imports: [
    TypeOrmModule.forRoot({
      type: 'postgres',
      host: 'localhost',
      port: 5432,
      username: 'wms_user',
      password: 'wms_password',
      database: 'warehouse_db',
      autoLoadEntities: true,
      synchronize: process.env.NODE_ENV !== 'production'
    }),
    WmsBaseModule.forRoot({
      enableAutomaticStockUpdates: true,
      defaultLocationCode: 'MAIN-A01',
      stockReservationEnabled: true,
      auditTrailEnabled: true
    })
  ]
})
export class AppModule {}
```

### Stock Management Service
```typescript
import { Injectable } from '@nestjs/common';
import { StockService, MaterialService } from '@rytass/wms-base-nestjs-module';

@Injectable()
export class InventoryService {
  constructor(
    private readonly stockService: StockService,
    private readonly materialService: MaterialService
  ) {}

  async receiveInventory(materialCode: string, quantity: number, locationCode: string, batchNumber?: string) {
    // Find material
    const material = await this.materialService.findByCode(materialCode);
    if (!material) {
      throw new Error(`Material ${materialCode} not found`);
    }

    // Record stock receipt
    const stockEntry = await this.stockService.addStock({
      materialId: material.id,
      locationCode,
      quantity,
      batchNumber,
      transactionType: 'RECEIPT',
      referenceNumber: `RCV-${Date.now()}`
    });

    return {
      material: material.code,
      quantity: stockEntry.quantity,
      location: locationCode,
      batch: batchNumber,
      newTotal: await this.stockService.getStockLevel(material.id, locationCode)
    };
  }

  async issueInventory(materialCode: string, quantity: number, locationCode: string, orderNumber: string) {
    const material = await this.materialService.findByCode(materialCode);
    
    // Check stock availability
    const availableStock = await this.stockService.getAvailableStock(material.id, locationCode);
    if (availableStock < quantity) {
      throw new Error(`Insufficient stock. Available: ${availableStock}, Required: ${quantity}`);
    }

    // Issue stock
    const stockEntry = await this.stockService.reduceStock({
      materialId: material.id,
      locationCode,
      quantity,
      transactionType: 'ISSUE',
      referenceNumber: orderNumber
    });

    return {
      material: material.code,
      issuedQuantity: quantity,
      remainingStock: stockEntry.quantity,
      location: locationCode
    };
  }

  async performStockCount(locationCode: string) {
    const stockItems = await this.stockService.getStockByLocation(locationCode);
    
    const countResults = [];
    for (const stock of stockItems) {
      const material = await this.materialService.findById(stock.materialId);
      countResults.push({
        materialCode: material.code,
        materialName: material.name,
        systemQuantity: stock.quantity,
        countedQuantity: 0, // To be updated by warehouse staff
        variance: 0,
        location: locationCode,
        batch: stock.batchNumber
      });
    }

    return countResults;
  }
}
```

### Order Processing Service
```typescript
import { Injectable } from '@nestjs/common';
import { OrderService, StockService } from '@rytass/wms-base-nestjs-module';

@Injectable()
export class OrderProcessingService {
  constructor(
    private readonly orderService: OrderService,
    private readonly stockService: StockService
  ) {}

  async createOutboundOrder(orderData: OutboundOrderDto) {
    // Create order
    const order = await this.orderService.createOrder({
      orderNumber: orderData.orderNumber,
      orderType: 'OUTBOUND',
      customerId: orderData.customerId,
      priority: orderData.priority || 'NORMAL',
      requestedDate: orderData.requestedDate,
      status: 'CREATED',
      items: orderData.items
    });

    // Reserve stock for order items
    for (const item of orderData.items) {
      await this.stockService.reserveStock({
        materialId: item.materialId,
        quantity: item.quantity,
        orderNumber: order.orderNumber,
        locationCode: item.preferredLocation || 'MAIN-A01'
      });
    }

    return order;
  }

  async processPickList(orderNumber: string) {
    const order = await this.orderService.findByOrderNumber(orderNumber);
    
    if (order.status !== 'CREATED') {
      throw new Error(`Order ${orderNumber} is not in valid status for picking`);
    }

    // Generate pick list
    const pickList = [];
    for (const item of order.items) {
      const stockAllocations = await this.stockService.allocateStock({
        materialId: item.materialId,
        quantity: item.quantity,
        strategy: 'FIFO' // First In, First Out
      });

      pickList.push({
        orderNumber: order.orderNumber,
        materialCode: item.material.code,
        materialName: item.material.name,
        quantityToPick: item.quantity,
        allocations: stockAllocations.map(alloc => ({
          location: alloc.locationCode,
          batch: alloc.batchNumber,
          quantity: alloc.quantity,
          pickSequence: alloc.pickSequence
        }))
      });
    }

    // Update order status
    await this.orderService.updateOrderStatus(order.id, 'PICKING');

    return {
      orderNumber: order.orderNumber,
      pickList,
      totalItems: pickList.length,
      priority: order.priority
    };
  }

  async confirmPicking(orderNumber: string, pickConfirmations: PickConfirmation[]) {
    const order = await this.orderService.findByOrderNumber(orderNumber);

    for (const confirmation of pickConfirmations) {
      await this.stockService.confirmPick({
        materialId: confirmation.materialId,
        locationCode: confirmation.locationCode,
        batchNumber: confirmation.batchNumber,
        quantityPicked: confirmation.quantityPicked,
        orderNumber: orderNumber
      });
    }

    // Check if all items are picked
    const allItemsPicked = await this.checkAllItemsPicked(orderNumber);
    
    if (allItemsPicked) {
      await this.orderService.updateOrderStatus(order.id, 'PICKED');
      
      // Move to packing stage
      return this.createPackingSlip(orderNumber);
    }

    return { status: 'PARTIAL_PICK', orderNumber };
  }
}
```

### Location Management Service
```typescript
import { Injectable } from '@nestjs/common';
import { LocationService } from '@rytass/wms-base-nestjs-module';

@Injectable()
export class WarehouseLayoutService {
  constructor(private readonly locationService: LocationService) {}

  async setupWarehouseLayout() {
    // Create main warehouse zones
    const receivingZone = await this.locationService.createLocation({
      code: 'RCV-ZONE',
      name: 'Receiving Zone',
      type: 'ZONE',
      capacity: 1000,
      isActive: true
    });

    const storageZone = await this.locationService.createLocation({
      code: 'STG-ZONE',
      name: 'Storage Zone',
      type: 'ZONE',
      capacity: 5000,
      isActive: true
    });

    const shippingZone = await this.locationService.createLocation({
      code: 'SHP-ZONE',
      name: 'Shipping Zone',
      type: 'ZONE',
      capacity: 800,
      isActive: true
    });

    // Create aisles in storage zone
    for (let i = 1; i <= 10; i++) {
      const aisle = await this.locationService.createLocation({
        code: `A${i.toString().padStart(2, '0')}`,
        name: `Aisle ${i}`,
        type: 'AISLE',
        parentLocationId: storageZone.id,
        capacity: 500
      });

      // Create rack positions in each aisle
      for (let j = 1; j <= 20; j++) {
        await this.locationService.createLocation({
          code: `A${i.toString().padStart(2, '0')}-R${j.toString().padStart(2, '0')}`,
          name: `Aisle ${i} Rack ${j}`,
          type: 'RACK',
          parentLocationId: aisle.id,
          capacity: 25
        });
      }
    }

    return {
      zones: [receivingZone, storageZone, shippingZone],
      message: 'Warehouse layout created successfully'
    };
  }

  async getLocationUtilization(locationCode: string) {
    const location = await this.locationService.findByCode(locationCode);
    const currentStock = await this.stockService.getStockByLocation(locationCode);
    
    const totalQuantity = currentStock.reduce((sum, stock) => sum + stock.quantity, 0);
    const utilizationPercentage = (totalQuantity / location.capacity) * 100;

    return {
      locationCode: location.code,
      locationName: location.name,
      capacity: location.capacity,
      currentStock: totalQuantity,
      utilization: Math.round(utilizationPercentage * 100) / 100,
      status: utilizationPercentage > 90 ? 'FULL' : utilizationPercentage > 70 ? 'HIGH' : 'NORMAL'
    };
  }
}
```

## Advanced Features

### Stock Collection and Sorting
```typescript
// Stock finding with advanced filters
const stockCollection = await stockService.findStock({
  materialIds: ['MAT-001', 'MAT-002'],
  locationCodes: ['A01-R01', 'A01-R02'],
  batchNumbers: ['BATCH-001'],
  minQuantity: 10,
  sortBy: StockSorter.QUANTITY_DESC
});

// Stock aggregation
const aggregatedStock = await stockService.getAggregatedStock({
  groupBy: ['materialId', 'locationCode'],
  filters: {
    isActive: true,
    quantity: { $gt: 0 }
  }
});
```

### Reporting and Analytics
```typescript
@Injectable()
export class WmsReportingService {
  async generateInventoryReport(dateRange: { from: Date; to: Date }) {
    const movements = await this.stockService.getStockMovements(dateRange);
    
    return {
      summary: {
        totalReceipts: movements.filter(m => m.type === 'RECEIPT').length,
        totalIssues: movements.filter(m => m.type === 'ISSUE').length,
        totalValue: movements.reduce((sum, m) => sum + m.value, 0)
      },
      byMaterial: this.groupMovementsByMaterial(movements),
      byLocation: this.groupMovementsByLocation(movements)
    };
  }

  async getWarehousePerformance() {
    return {
      orderFulfillmentRate: await this.calculateFulfillmentRate(),
      averagePickTime: await this.calculateAveragePickTime(),
      stockTurnover: await this.calculateStockTurnover(),
      locationUtilization: await this.calculateLocationUtilization()
    };
  }
}
```

## Dependencies

- **TypeORM**: Database ORM for entity management
- **NestJS**: Framework integration with dependency injection

## Configuration Options

```typescript
interface WmsBaseModuleOptions {
  enableAutomaticStockUpdates: boolean;
  defaultLocationCode: string;
  stockReservationEnabled: boolean;
  auditTrailEnabled: boolean;
  stockNegativeAllowed: boolean;
  batchTrackingRequired: boolean;
}
```

## Use Cases

### E-commerce Fulfillment
- Order processing and picking optimization
- Inventory tracking for online stores
- Returns and refund processing
- Multi-channel inventory management

### Manufacturing Supply Chain
- Raw material management
- Work-in-progress tracking
- Finished goods handling
- Just-in-time inventory

### 3PL Operations
- Multi-client inventory segregation
- Cross-docking operations
- Value-added services
- Customer reporting

This WMS base module provides a solid foundation for building comprehensive warehouse management solutions with NestJS, offering flexibility for various warehouse operation models and business requirements.