# Rytass Utils - iCash Pay Payment Adapter

## Package Information
- **Package**: `@rytass/payments-adapter-icash-pay`
- **Version**: 0.1.2
- **Description**: Comprehensive TypeScript payment adapter for iCash Pay digital payment system, Taiwan's leading barcode-based payment solution
- **Author**: Chia Yu Pai <fantasyatelier@gmail.com>
- **License**: MIT
- **Repository**: https://github.com/Rytass/Utils

## Overview
This adapter provides seamless integration with iCash Pay's digital payment ecosystem, offering barcode-based payment processing with support for digital wallets, credit cards, bank transfers, mobile invoice integration, member systems, and comprehensive payment lifecycle management with advanced security features.

## Installation
```bash
npm install @rytass/payments-adapter-icash-pay
# or
yarn add @rytass/payments-adapter-icash-pay
```

## Dependencies
- `@rytass/payments`: ^0.2.2
- `axios`: ^1.7.8
- `debug`: ^4.3.7
- `luxon`: ^3.5.0

## Peer Dependencies
None required.

## Key Features
- ✅ iCash Pay barcode-based payment processing
- ✅ Multiple payment types (iCash digital wallet, credit card, bank transfer)
- ✅ Secure AES encryption and RSA signature verification
- ✅ Transaction query and status tracking
- ✅ Refund and partial refund operations
- ✅ Mobile invoice carrier integration
- ✅ Taiwan QR Code (TWQR) support
- ✅ Uni Member integration with GID support
- ✅ Bonus point and stored value management
- ✅ Store-based transaction management
- ✅ Production and development environment support
- ✅ TypeScript type safety throughout
- ✅ Event-driven architecture with payment lifecycle events
- ✅ Multi-amount transaction support (item, utility, commission amounts)

## Basic Usage

### Simple Barcode Payment
```typescript
import { 
  ICashPayPayment, 
  ICashPayBaseUrls, 
  ICashPayPaymentType 
} from '@rytass/payments-adapter-icash-pay';
import { PaymentEvents } from '@rytass/payments';

const paymentGateway = new ICashPayPayment({
  baseUrl: ICashPayBaseUrls.PRODUCTION,
  merchantId: process.env.ICASH_PAY_MERCHANT_ID!,
  clientPrivateKey: process.env.ICASH_PAY_CLIENT_PRIVATE_KEY!,
  serverPublicKey: process.env.ICASH_PAY_SERVER_PUBLIC_KEY!,
  aesKey: {
    id: process.env.ICASH_PAY_AES_KEY_ID!,
    key: process.env.ICASH_PAY_AES_KEY!, // 32 characters
    iv: process.env.ICASH_PAY_AES_IV!   // 16 characters
  }
});

// Setup payment event listeners
paymentGateway.emitter.on(PaymentEvents.ORDER_COMMITTED, (message) => {
  console.log('iCash Pay payment successful:', message.id);
  console.log('Transaction ID:', message.transactionId);
  console.log('Payment Type:', message.paymentType);
  console.log('Amount Paid:', message.totalPrice);
});

// Create barcode payment order
const order = await paymentGateway.prepare({
  id: 'ORDER-2024-001',
  storeName: 'My Coffee Shop',
  storeId: 'STORE001',
  barcode: '280012345678901234', // Customer's iCash Pay barcode
  amount: 150,
  items: [
    {
      name: 'Americano Coffee',
      unitPrice: 120,
      quantity: 1
    },
    {
      name: 'Service Fee',
      unitPrice: 30,
      quantity: 1
    }
  ]
});

// Process the payment
const commitResult = await order.commit();
if (commitResult.success) {
  console.log('Payment processed successfully');
  console.log('Transaction ID:', order.transactionId);
  console.log('iCP Account:', order.icpAccount);
} else {
  console.error('Payment failed:', commitResult.error);
}
```

### Multi-Amount Transaction
```typescript
// Complex transaction with multiple amount types
const complexOrder = await paymentGateway.prepare({
  id: 'COMPLEX-ORDER-001',
  storeName: 'Department Store',
  storeId: 'DS001',
  barcode: '280012345678901234',
  amount: 1000,                     // Total amount
  collectedAmount: 800,             // Amount collected by store
  consignmentAmount: 200,           // Consignment amount
  nonRedeemAmount: 100,             // Non-redeemable amount
  collectedNonRedeemAmount: 80,     // Collected non-redeemable amount
  consignmentNonRedeemAmount: 20,   // Consignment non-redeemable amount
  nonPointAmount: 50,               // Amount not earning points
  items: [
    {
      name: 'Premium Product',
      unitPrice: 800,
      quantity: 1
    },
    {
      name: 'Consignment Item',
      unitPrice: 200,
      quantity: 1
    }
  ]
});
```

### Payment Query
```typescript
// Query payment status
const paymentStatus = await paymentGateway.query('ORDER-2024-001');

console.log('Order ID:', paymentStatus.id);
console.log('Transaction ID:', paymentStatus.transactionId);
console.log('Trade Status:', paymentStatus.tradeStatus);
console.log('Payment Type:', paymentStatus.paymentType);
console.log('iCP Account:', paymentStatus.icpAccount);
console.log('Paid Amount:', paymentStatus.paidAmount);
console.log('Bonus Amount:', paymentStatus.bonusAmount);

// Check if payment is completed
if (paymentStatus.isCommitted) {
  console.log('Payment completed at:', paymentStatus.committedAt);
} else if (paymentStatus.isFailed) {
  console.log('Payment failed:', paymentStatus.failedMessage);
}
```

## Configuration Options

### ICashPayPaymentInitOptions
| Property | Type | Required | Description |
|----------|------|----------|-------------|
| `baseUrl` | `ICashPayBaseUrls` | Yes | API endpoint URL (production/development) |
| `merchantId` | `string` | Yes | iCash Pay merchant ID |
| `clientPrivateKey` | `string` | Yes | RSA private key for signing |
| `serverPublicKey` | `string` | Yes | iCash Pay server public key |
| `aesKey` | `ICashPayAESKey` | Yes | AES encryption configuration |
| `logLevel` | `LogLevel` | No | Logging level (ERROR/INFO/DEBUG) |

### AES Key Configuration
```typescript
interface ICashPayAESKey {
  id: string;      // AES key identifier
  key: string;     // 32-character AES key
  iv: string;      // 16-character AES IV
}
```

### Environment Configuration
```typescript
// Production configuration
const productionGateway = new ICashPayPayment({
  baseUrl: ICashPayBaseUrls.PRODUCTION,
  merchantId: process.env.ICASH_PAY_MERCHANT_ID!,
  clientPrivateKey: process.env.ICASH_PAY_CLIENT_PRIVATE_KEY!,
  serverPublicKey: process.env.ICASH_PAY_SERVER_PUBLIC_KEY!,
  aesKey: {
    id: process.env.ICASH_PAY_AES_KEY_ID!,
    key: process.env.ICASH_PAY_AES_KEY!,
    iv: process.env.ICASH_PAY_AES_IV!
  },
  logLevel: LogLevel.INFO
});

// Development configuration
const developmentGateway = new ICashPayPayment({
  baseUrl: ICashPayBaseUrls.DEVELOPMENT,
  merchantId: 'TEST_MERCHANT_ID',
  clientPrivateKey: process.env.ICASH_PAY_CLIENT_PRIVATE_KEY!,
  serverPublicKey: process.env.ICASH_PAY_SERVER_PUBLIC_KEY!,
  aesKey: {
    id: process.env.ICASH_PAY_AES_KEY_ID!,
    key: process.env.ICASH_PAY_AES_KEY!,
    iv: process.env.ICASH_PAY_AES_IV!
  },
  logLevel: LogLevel.DEBUG
});
```

## Payment Types and Trade Status

### Payment Types
```typescript
enum ICashPayPaymentType {
  CREDIT_CARD = '0',  // Credit card payments
  I_CASH = '1',       // iCash digital wallet
  BANK = '2'          // Bank transfer
}

// Check payment type after transaction
const checkPaymentType = (order: ICashPayOrder) => {
  switch (order.paymentType) {
    case ICashPayPaymentType.CREDIT_CARD:
      console.log('Payment via credit card');
      console.log('Card info:', order.creditCardFirstSix, '****', order.creditCardLastFour);
      break;
    case ICashPayPaymentType.I_CASH:
      console.log('Payment via iCash digital wallet');
      console.log('iCP Account:', order.icpAccount);
      break;
    case ICashPayPaymentType.BANK:
      console.log('Payment via bank transfer');
      break;
  }
};
```

### Trade Status Management
```typescript
enum ICashPayTradeStatus {
  INITED = '0',              // Transaction initiated
  COMMITTED = '1',           // Transaction completed
  REFUNDED = '2',            // Fully refunded
  PARTIAL_REFUNDED = '3',    // Partially refunded
  CANCELLED = '4',           // Transaction cancelled
  WAITING_SETTLEMENT = '5',  // Waiting for settlement
  SETTLEMENT_FAILED = '6',   // Settlement failed
  FAILED = '7'               // Transaction failed
}

// Handle different trade statuses
const handleTradeStatus = (order: ICashPayOrder) => {
  switch (order.tradeStatus) {
    case ICashPayTradeStatus.COMMITTED:
      console.log('Payment successful and completed');
      break;
    case ICashPayTradeStatus.WAITING_SETTLEMENT:
      console.log('Payment pending settlement');
      break;
    case ICashPayTradeStatus.FAILED:
      console.log('Payment failed:', order.failedMessage);
      break;
    case ICashPayTradeStatus.REFUNDED:
      console.log('Payment has been refunded');
      break;
  }
};
```

## Advanced Features

### Mobile Invoice Integration
```typescript
// Payment with mobile invoice carrier
const invoiceOrder = await paymentGateway.prepare({
  id: 'INVOICE-ORDER-001',
  storeName: 'Electronic Store',
  barcode: '280012345678901234',
  amount: 5000,
  items: [
    {
      name: 'Smartphone',
      unitPrice: 5000,
      quantity: 1,
      mobileInvoiceCarrier: '/ABC12345'  // Customer's mobile carrier barcode
    }
  ]
});

// After payment, check invoice information
const result = await invoiceOrder.commit();
if (result.success) {
  console.log('Mobile Invoice Carrier:', invoiceOrder.invoiceMobileCarrier);
  console.log('TWQR Code:', invoiceOrder.isTWQRCode);
  console.log('TWQR Issue Code:', invoiceOrder.twqrIssueCode);
}
```

### Member Integration
```typescript
// Payment with member integration
const memberOrder = await paymentGateway.prepare({
  id: 'MEMBER-ORDER-001',
  storeName: 'Loyalty Store',
  barcode: '280012345678901234',
  amount: 300,
  items: [
    {
      name: 'Member Special Item',
      unitPrice: 300,
      quantity: 1,
      memberGID: 'UNI_MEMBER_123456',    // Uni Member ID
      boundMemberId: 'STORE_MEMBER_789'   // Store's member system ID
    }
  ]
});

// Check member information after payment
const memberResult = await memberOrder.commit();
if (memberResult.success) {
  console.log('Bound Member ID:', memberOrder.boundMemberId);
  console.log('Uni GID:', memberOrder.uniGID);
}
```

### Credit Card Payment Tracking
```typescript
// For credit card payments, track card information
const creditOrder = await paymentGateway.prepare({
  id: 'CREDIT-ORDER-001',
  storeName: 'Online Store',
  barcode: '280012345678901234',
  amount: 2500,
  items: [
    {
      name: 'Online Purchase',
      unitPrice: 2500,
      quantity: 1
    }
  ]
});

const creditResult = await creditOrder.commit();
if (creditResult.success && creditOrder.paymentType === ICashPayPaymentType.CREDIT_CARD) {
  console.log('Credit Card Payment');
  console.log('Card First 6:', creditOrder.creditCardFirstSix);
  console.log('Card Last 4:', creditOrder.creditCardLastFour);
  console.log('Masked PAN:', creditOrder.maskedPan);
}
```

### Transaction Refund
```typescript
// Full refund
const fullRefund = await paymentGateway.refund({
  id: 'ORDER-2024-001',
  storeName: 'My Coffee Shop',
  transactionId: 'TXN123456789',
  requestRefundAmount: 150          // Full amount
});

if (fullRefund.success) {
  console.log('Full refund processed');
  console.log('Refund Transaction ID:', fullRefund.transactionId);
  console.log('Refunded Amount:', fullRefund.refundedAmount);
}

// Partial refund with detailed amounts
const partialRefund = await paymentGateway.refund({
  id: 'COMPLEX-ORDER-001',
  storeId: 'DS001',
  storeName: 'Department Store', 
  transactionId: 'TXN987654321',
  requestRefundAmount: 500,                    // Total refund amount
  requestRefundCollectedAmount: 400,           // Collected amount to refund
  requestRefundConsignmentAmount: 100,         // Consignment amount to refund
  refundOrderId: 'REFUND-001'                  // Optional refund order ID
});

if (partialRefund.success) {
  console.log('Partial refund processed');
  console.log('Original Amount:', partialRefund.originalAmount);
  console.log('Refunded iCP Amount:', partialRefund.refundedICPAmount);
  console.log('Refunded Bonus Amount:', partialRefund.refundedBonusAmount);
}
```

## Error Handling
```typescript
try {
  const order = await paymentGateway.prepare({
    storeName: 'Test Store',
    barcode: '280012345678901234',
    amount: 1000,
    items: [/* items */]
  });
  
  const result = await order.commit();
} catch (error) {
  // Handle different types of errors
  if (error.message.includes('Invalid barcode format')) {
    console.error('Barcode format is incorrect - must be 18 digits');
  } else if (error.message.includes('Insufficient balance')) {
    console.error('Customer does not have sufficient iCash Pay balance');
  } else if (error.message.includes('Merchant not authorized')) {
    console.error('Merchant credentials are invalid or expired');
  } else if (error.message.includes('Transaction limit exceeded')) {
    console.error('Transaction amount exceeds daily or single transaction limit');
  } else if (error.message.includes('Network timeout')) {
    console.error('Connection to iCash Pay service timed out');
  } else if (error.message.includes('Encryption error')) {
    console.error('AES/RSA encryption/decryption failed');
  } else {
    console.error('Unexpected payment error:', error.message);
  }
}
```

### Validation Helpers
```typescript
// Barcode validation
const validateICashPayBarcode = (barcode: string): boolean => {
  return /^\d{18}$/.test(barcode);
};

// Amount validation
const validateAmounts = (amounts: {
  total: number;
  collected?: number;
  consignment?: number;
  nonRedeem?: number;
}) => {
  if (amounts.total <= 0) {
    throw new Error('Total amount must be greater than 0');
  }
  
  const calculatedTotal = (amounts.collected || 0) + (amounts.consignment || 0);
  if (calculatedTotal > 0 && calculatedTotal !== amounts.total) {
    throw new Error('Collected + Consignment amounts must equal total amount');
  }
  
  if (amounts.nonRedeem && amounts.nonRedeem > amounts.total) {
    throw new Error('Non-redeemable amount cannot exceed total amount');
  }
};
```

## Integration Examples

### Express.js Integration
```typescript
import express from 'express';
import { ICashPayPayment, ICashPayBaseUrls, ICashPayPaymentType } from '@rytass/payments-adapter-icash-pay';
import { PaymentEvents } from '@rytass/payments';

const app = express();
app.use(express.json());

const paymentGateway = new ICashPayPayment({
  baseUrl: process.env.NODE_ENV === 'production' 
    ? ICashPayBaseUrls.PRODUCTION 
    : ICashPayBaseUrls.DEVELOPMENT,
  merchantId: process.env.ICASH_PAY_MERCHANT_ID!,
  clientPrivateKey: process.env.ICASH_PAY_CLIENT_PRIVATE_KEY!,
  serverPublicKey: process.env.ICASH_PAY_SERVER_PUBLIC_KEY!,
  aesKey: {
    id: process.env.ICASH_PAY_AES_KEY_ID!,
    key: process.env.ICASH_PAY_AES_KEY!,
    iv: process.env.ICASH_PAY_AES_IV!
  }
});

// Handle payment success
paymentGateway.emitter.on(PaymentEvents.ORDER_COMMITTED, async (message) => {
  // Update database
  await updateOrderStatus(message.id, 'paid');
  
  // Send confirmation
  await sendPaymentConfirmation(message.id, {
    transactionId: message.transactionId,
    paymentType: message.paymentType,
    paidAmount: message.totalPrice
  });
  
  console.log(`iCash Pay payment committed: ${message.id}`);
});

// Create payment endpoint
app.post('/api/payments/icash-pay', async (req, res) => {
  try {
    const { 
      orderId, 
      storeName, 
      storeId, 
      barcode, 
      items, 
      amounts,
      memberInfo
    } = req.body;
    
    const order = await paymentGateway.prepare({
      id: orderId,
      storeName,
      storeId,
      barcode,
      amount: amounts.total,
      collectedAmount: amounts.collected,
      consignmentAmount: amounts.consignment,
      nonRedeemAmount: amounts.nonRedeem,
      nonPointAmount: amounts.nonPoint,
      items: items.map(item => ({
        name: item.name,
        unitPrice: item.price,
        quantity: item.quantity,
        memberGID: memberInfo?.uniGID,
        boundMemberId: memberInfo?.storeMemberId,
        mobileInvoiceCarrier: item.invoiceCarrier
      }))
    });
    
    // Process payment
    const result = await order.commit();
    
    if (result.success) {
      res.json({
        success: true,
        payment: {
          orderId: order.id,
          transactionId: order.transactionId,
          paymentType: order.paymentType,
          icpAccount: order.icpAccount,
          paidAmount: order.paidAmount,
          bonusAmount: order.bonusAmount,
          committedAt: order.committedAt
        }
      });
    } else {
      res.status(400).json({
        success: false,
        error: result.error
      });
    }
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

// Query payment status endpoint
app.get('/api/payments/icash-pay/:orderId/status', async (req, res) => {
  try {
    const { orderId } = req.params;
    
    const order = await paymentGateway.query(orderId);
    
    res.json({
      success: true,
      payment: {
        orderId: order.id,
        transactionId: order.transactionId,
        tradeStatus: order.tradeStatus,
        paymentType: order.paymentType,
        icpAccount: order.icpAccount,
        paidAmount: order.paidAmount,
        bonusAmount: order.bonusAmount,
        isCommitted: order.isCommitted,
        isFailed: order.isFailed,
        isRefunded: order.isRefunded,
        committedAt: order.committedAt,
        failedMessage: order.failedMessage
      }
    });
  } catch (error) {
    res.status(404).json({
      success: false,
      error: 'Payment not found'
    });
  }
});

// Refund endpoint
app.post('/api/payments/icash-pay/:orderId/refund', async (req, res) => {
  try {
    const { orderId } = req.params;
    const { 
      storeName, 
      storeId, 
      refundAmount, 
      refundCollectedAmount, 
      refundConsignmentAmount,
      refundOrderId
    } = req.body;
    
    // Get original order to obtain transaction ID
    const originalOrder = await paymentGateway.query(orderId);
    
    if (!originalOrder.transactionId) {
      return res.status(400).json({
        success: false,
        error: 'Transaction ID not found for this order'
      });
    }
    
    const refundResult = await paymentGateway.refund({
      id: orderId,
      storeName,
      storeId,
      transactionId: originalOrder.transactionId,
      requestRefundAmount: refundAmount,
      requestRefundCollectedAmount: refundCollectedAmount,
      requestRefundConsignmentAmount: refundConsignmentAmount,
      refundOrderId
    });
    
    if (refundResult.success) {
      res.json({
        success: true,
        refund: {
          orderId,
          refundTransactionId: refundResult.transactionId,
          refundedAmount: refundResult.refundedAmount,
          refundedICPAmount: refundResult.refundedICPAmount,
          refundedBonusAmount: refundResult.refundedBonusAmount,
          originalAmount: refundResult.originalAmount,
          processedAt: refundResult.processedAt
        }
      });
    } else {
      res.status(400).json({
        success: false,
        error: refundResult.error
      });
    }
  } catch (error) {
    res.status(500).json({
      success: false,
      error: error.message
    });
  }
});

app.listen(3000, () => {
  console.log('iCash Pay payment server running on port 3000');
});
```

## Security

### Encryption and Signing
iCash Pay uses RSA + AES hybrid encryption:

```typescript
// Example key generation (for development)
const crypto = require('crypto');

// Generate RSA key pair
const { publicKey, privateKey } = crypto.generateKeyPairSync('rsa', {
  modulusLength: 2048,
  publicKeyEncoding: {
    type: 'spki',
    format: 'pem'
  },
  privateKeyEncoding: {
    type: 'pkcs8',
    format: 'pem'
  }
});

// Generate AES key and IV
const aesKey = crypto.randomBytes(32).toString('hex'); // 32 bytes = 256 bits
const aesIV = crypto.randomBytes(16).toString('hex');  // 16 bytes = 128 bits

console.log('Client Private Key:', privateKey);
console.log('AES Key:', aesKey);
console.log('AES IV:', aesIV);
```

### Best Practices
- Store private keys securely and never expose them in client-side code
- Use different key sets for development and production environments
- Implement proper key rotation procedures
- Validate all encrypted responses before processing
- Log security events for audit purposes
- Use HTTPS for all API communications

## Testing

```typescript
import { ICashPayPayment, ICashPayBaseUrls, ICashPayPaymentType } from '@rytass/payments-adapter-icash-pay';
import { OrderState } from '@rytass/payments';

describe('iCash Pay Payment Integration', () => {
  let paymentGateway: ICashPayPayment;
  
  beforeEach(() => {
    paymentGateway = new ICashPayPayment({
      baseUrl: ICashPayBaseUrls.DEVELOPMENT,
      merchantId: 'TEST_MERCHANT',
      clientPrivateKey: process.env.TEST_CLIENT_PRIVATE_KEY!,
      serverPublicKey: process.env.TEST_SERVER_PUBLIC_KEY!,
      aesKey: {
        id: 'TEST_KEY_ID',
        key: 'TEST_AES_KEY_32_CHARACTERS_LONG',
        iv: 'TEST_AES_IV_16C'
      }
    });
  });
  
  it('should create order successfully', async () => {
    const order = await paymentGateway.prepare({
      storeName: 'Test Store',
      barcode: '280012345678901234',
      amount: 1000,
      items: [
        {
          name: 'Test Product',
          unitPrice: 1000,
          quantity: 1
        }
      ]
    });
    
    expect(order.id).toBeDefined();
    expect(order.totalPrice).toBe(1000);
    expect(order.storeName).toBe('Test Store');
    expect(order.state).toBe(OrderState.PRE_COMMIT);
  });
  
  it('should process payment successfully', async () => {
    const order = await paymentGateway.prepare({
      storeName: 'Test Store',
      barcode: '280012345678901234',
      amount: 500,
      items: [
        {
          name: 'Test Item',
          unitPrice: 500,
          quantity: 1
        }
      ]
    });
    
    const result = await order.commit();
    
    expect(result.success).toBe(true);
    expect(order.state).toBe(OrderState.COMMITTED);
    expect(order.transactionId).toBeDefined();
    expect(order.committedAt).toBeDefined();
  });
  
  it('should handle refunds', async () => {
    const refundResult = await paymentGateway.refund({
      id: 'TEST-ORDER-001',
      storeName: 'Test Store',
      transactionId: 'TEST-TXN-001',
      requestRefundAmount: 500
    });
    
    expect(refundResult.success).toBe(true);
    expect(refundResult.refundedAmount).toBe(500);
    expect(refundResult.transactionId).toBeDefined();
  });
  
  it('should validate barcode format', () => {
    const validBarcode = '280012345678901234';
    const invalidBarcode = '123456789';
    
    expect(validateICashPayBarcode(validBarcode)).toBe(true);
    expect(validateICashPayBarcode(invalidBarcode)).toBe(false);
  });
});
```

## Environment Variables
```bash
# .env
ICASH_PAY_MERCHANT_ID=your_merchant_id
ICASH_PAY_CLIENT_PRIVATE_KEY=your_client_private_key
ICASH_PAY_SERVER_PUBLIC_KEY=icash_pay_server_public_key
ICASH_PAY_AES_KEY_ID=your_aes_key_id
ICASH_PAY_AES_KEY=your_32_char_aes_key
ICASH_PAY_AES_IV=your_16_char_aes_iv
```

## API Reference

### ICashPayPayment Methods

#### `prepare(options: ICashPayPrepareOptions): Promise<ICashPayOrder>`
Creates a new iCash Pay payment order.

#### `query(orderId: string): Promise<ICashPayOrder>`
Queries payment status by order ID.

#### `refund(options: ICashPayRefundOptions): Promise<ICashPayRefundResult>`
Refunds an iCash Pay transaction.

### Constants and Enums

```typescript
// API endpoints
enum ICashPayBaseUrls {
  PRODUCTION = 'https://payment.icashpay.com.tw/api/V2/Payment',
  DEVELOPMENT = 'https://icp-payment-preprod.icashpay.com.tw/api/V2/Payment'
}

// Log levels
enum LogLevel {
  ERROR = 1,   // Error messages only
  INFO = 2,    // Info and error messages
  DEBUG = 4    // All messages including debug
}
```

## Related Packages
- `@rytass/payments` - Core payment framework
- `@rytass/payments-nestjs-module` - NestJS integration module
- Other payment adapters: ECPay, NewebPay, HwaNan, CTBC, Happy Card

## Support
- GitHub Issues: https://github.com/Rytass/Utils/issues
- Documentation: Package README and TypeScript definitions
- Community: Taiwan payment processing developers
- iCash Pay Support: Contact your iCash Pay account manager for technical issues